<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title> | Blackchena</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Blackchena</h1><a id="logo" href="/.">Blackchena</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title"></h1><div class="post-meta">2021-04-09</div><div class="post-content"><h1 id="Java核心类学习"><a href="#Java核心类学习" class="headerlink" title="Java核心类学习"></a>Java核心类学习</h1><h2 id="字符串和编码"><a href="#字符串和编码" class="headerlink" title="字符串和编码"></a>字符串和编码</h2><p>实际上字符串在<code>String</code>内部是通过一个<code>char[]</code>数组表示的，因此，按下面的写法也是可以的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s2 = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[] &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;!&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>字符串比较</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        System.out.println(s1.equals(s2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个字符串用<code>==</code>和<code>equals()</code>比较都为<code>true</code>，但实际上那只是Java编译器在编译期，会自动把所有相同的字符串当作一个对象放入<strong>常量池</strong>，自然<code>s1</code>和<code>s2</code>的引用就是相同的</p>
<p><strong>类型转换</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String.valueOf(123); &#x2F;&#x2F; &quot;123&quot;</span><br><span class="line">String.valueOf(45.67); &#x2F;&#x2F; &quot;45.67&quot;</span><br><span class="line">String.valueOf(true); &#x2F;&#x2F; &quot;true&quot;</span><br><span class="line">String.valueOf(new Object()); &#x2F;&#x2F; 类似java.lang.Object@636be97c</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int n1 &#x3D; Integer.parseInt(&quot;123&quot;); &#x2F;&#x2F; 123</span><br><span class="line">int n2 &#x3D; Integer.parseInt(&quot;ff&quot;, 16); &#x2F;&#x2F; 按十六进制转换，255</span><br></pre></td></tr></table></figure>

<p><code>Integer</code>有个<code>getInteger(String)</code>方法，它不是将字符串转换为<code>int</code>，而是把该字符串对应的系统变量转换为<code>Integer</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer.getInteger(<span class="string">&quot;java.version&quot;</span>); <span class="comment">// 版本号，11</span></span><br></pre></td></tr></table></figure>

<p><strong>字符编码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] b1 = <span class="string">&quot;Hello&quot;</span>.getBytes(); <span class="comment">// 按系统默认编码转换，不推荐</span></span><br><span class="line"><span class="keyword">byte</span>[] b2 = <span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>); <span class="comment">// 按UTF-8编码转换</span></span><br><span class="line"><span class="keyword">byte</span>[] b2 = <span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;GBK&quot;</span>); <span class="comment">// 按GBK编码转换</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] b = ...</span><br><span class="line">String s1 = <span class="keyword">new</span> String(b, <span class="string">&quot;GBK&quot;</span>); <span class="comment">// 按GBK转换</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String(b, StandardCharsets.UTF_8); <span class="comment">// 按UTF-8转换</span></span><br></pre></td></tr></table></figure>

<p>始终牢记：Java的<code>String</code>和<code>char</code>在内存中总是以Unicode编码表示，而且是用UTF-16的编码格式<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/35172335">Java char 型了解一下 - 知乎</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String testStr = <span class="string">&quot;H&quot;</span>;</span><br><span class="line"><span class="keyword">byte</span>[] b1 = testStr.getBytes(StandardCharsets.UTF_16);</span><br></pre></td></tr></table></figure>

<p>上面的<code>b1</code>数组长度为4，前两个字节0xfe，0xff，字符U+FEFF如果出现在字节流的开头，则用来标识该字节流的字节序，是高位在前还是低位在前<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%85%83%E7%B5%84%E9%A0%86%E5%BA%8F%E8%A8%98%E8%99%9F">字节顺序标记</a></p>
<h2 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h2><table>
<thead>
<tr>
<th align="left">基本类型</th>
<th align="left">对应的引用类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">boolean</td>
<td align="left">java.lang.Boolean</td>
</tr>
<tr>
<td align="left">byte</td>
<td align="left">java.lang.Byte</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">java.lang.Short</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">java.lang.Integer</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">java.lang.Long</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">java.lang.Float</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">java.lang.Double</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">java.lang.Character</td>
</tr>
</tbody></table>
<p><strong>Auto Boxing/Auto Unboxing</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer n = <span class="number">100</span>; <span class="comment">// 编译器自动使用Integer.valueOf(int)</span></span><br><span class="line"><span class="keyword">int</span> x = n; <span class="comment">// 编译器自动使用Integer.intValue()</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer x = <span class="number">127</span>;</span><br><span class="line">        Integer y = <span class="number">127</span>;</span><br><span class="line">        Integer m = <span class="number">99999</span>;</span><br><span class="line">        Integer n = <span class="number">99999</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;x == y: &quot;</span> + (x==y)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;m == n: &quot;</span> + (m==n)); <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;x.equals(y): &quot;</span> + x.equals(y)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;m.equals(n): &quot;</span> + m.equals(n)); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p>仔细观察结果的童鞋可以发现，<code>==</code>比较，较小的两个相同的<code>Integer</code>返回<code>true</code>，较大的两个相同的<code>Integer</code>返回<code>false</code>，这是因为<code>Integer</code>是不变类，编译器把<code>Integer x = 127;</code>*<em>自动变为<code>Integer x = Integer.valueOf(127);</code>，为了节省内存，<code>Integer.valueOf()</code>对于较小的数，始终返回相同的实例，因此，<code>==</code>比较“恰好”为<code>true</code>**，但我们</em>绝不能*因为Java标准库的<code>Integer</code>内部有缓存优化就用<code>==</code>比较，必须用<code>equals()</code>方法比较两个<code>Integer</code>。</p>
<p> 按照语义编程，而不是针对特定的底层实现去“优化”。</p>
<p>因为<code>Integer.valueOf()</code>可能始终返回同一个<code>Integer</code>实例，因此，在我们自己创建<code>Integer</code>的时候，以下两种方法：</p>
<ul>
<li>方法1：<code>Integer n = new Integer(100);</code></li>
<li>方法2：<code>Integer n = Integer.valueOf(100);</code></li>
</ul>
<p>方法2更好，因为方法1总是创建新的<code>Integer</code>实例，方法2把内部优化留给<code>Integer</code>的实现者去做，即使在当前版本没有优化，也有可能在下一个版本进行优化。</p>
<p><strong>我们把能创建“新”对象的静态方法称为静态工厂方法</strong>。<code>Integer.valueOf()</code>就是静态工厂方法，它尽可能地返回缓存的实例以节省内存。</p>
<p> 创建新对象时，优先选用静态工厂方法而不是new操作符。</p>
<p>如果我们考察<code>Byte.valueOf()</code>方法的源码，可以看到，标准库返回的<code>Byte</code>实例全部是缓存实例，但调用者并不关心静态工厂方法以何种方式创建新实例还是直接返回缓存的实例。</p>
<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>通过<code>enum</code>定义的枚举类，和其他的<code>class</code>有什么区别？</p>
<p>答案是没有任何区别。<code>enum</code>定义的类型就是<code>class</code>，只不过它有以下几个特点：</p>
<ul>
<li>定义的<code>enum</code>类型总是继承自<code>java.lang.Enum</code>，且无法被继承；</li>
<li>只能定义出<code>enum</code>的实例，而无法通过<code>new</code>操作符创建<code>enum</code>的实例；</li>
<li>定义的每个实例都是引用类型的唯一实例；</li>
<li>可以将<code>enum</code>类型用于<code>switch</code>语句。</li>
</ul>
<p>我们可以定义<code>private</code>的构造方法，并且，给每个枚举常量添加字段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> </span>&#123;</span><br><span class="line">    MON(<span class="number">1</span>), TUE(<span class="number">2</span>), WED(<span class="number">3</span>), THU(<span class="number">4</span>), FRI(<span class="number">5</span>), SAT(<span class="number">6</span>), SUN(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> dayValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Weekday</span><span class="params">(<span class="keyword">int</span> dayValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dayValue = dayValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，对枚举常量调用<code>toString()</code>会返回和<code>name()</code>一样的字符串即MON，TUE这种</p>
<h2 id="BigInteger-BigDecimal"><a href="#BigInteger-BigDecimal" class="headerlink" title="BigInteger/BigDecimal"></a>BigInteger/BigDecimal</h2><p><strong>BigInteger</strong></p>
<p>在Java中，由CPU原生提供的整型最大范围是64位<code>long</code>型整数。使用<code>long</code>型整数可以直接通过CPU指令进行计算，速度非常快。</p>
<p>如果我们使用的整数范围超过了<code>long</code>型怎么办？这个时候，就只能用软件来模拟一个大整数。<code>java.math.BigInteger</code>就是用来表示任意大小的整数。<code>BigInteger</code>内部用一个<code>int[]</code>数组来模拟一个非常大的整数</p>
<p>也可以把<code>BigInteger</code>转换成<code>long</code>型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigInteger i &#x3D; new BigInteger(&quot;123456789000&quot;);</span><br><span class="line">System.out.println(i.longValue()); &#x2F;&#x2F; 123456789000如果BigInteger表示的范围超过了基本类型的范围，转换时将丢失高位信息</span><br><span class="line">System.out.println(i.multiply(i).longValueExact()); &#x2F;&#x2F; java.lang.ArithmeticException: BigInteger out of long range</span><br></pre></td></tr></table></figure>

<p>使用<code>longValueExact()</code>方法时，如果超出了<code>long</code>型的范围，会抛出<code>ArithmeticException</code></p>
<p><strong>BigDecimal</strong></p>
<p>通过<code>BigDecimal</code>的<code>stripTrailingZeros()</code>方法，可以将一个<code>BigDecimal</code>格式化为一个相等的，但去掉了末尾0的<code>BigDecimal</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.4500&quot;</span>);</span><br><span class="line">BigDecimal d2 = d1.stripTrailingZeros();</span><br><span class="line">System.out.println(d1.scale()); <span class="comment">// 4</span></span><br><span class="line">System.out.println(d2.scale()); <span class="comment">// 2,因为去掉了00</span></span><br><span class="line"></span><br><span class="line">BigDecimal d3 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1234500&quot;</span>);</span><br><span class="line">BigDecimal d4 = d3.stripTrailingZeros();</span><br><span class="line">System.out.println(d3.scale()); <span class="comment">// 0</span></span><br><span class="line">System.out.println(d4.scale()); <span class="comment">// -2 可以判断整数后面有几个零 这里是2个</span></span><br></pre></td></tr></table></figure>

<p>对<code>BigDecimal</code>做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal d3 = d1.divide(d2, <span class="number">10</span>, RoundingMode.HALF_UP); <span class="comment">// 保留10位小数并四舍五入</span></span><br></pre></td></tr></table></figure>

<p>调用<code>divideAndRemainder()</code>方法时，返回的数组包含两个<code>BigDecimal</code>，分别是商和余数，其中商总是整数，余数不会大于除数。我们可以利用这个方法判断两个<code>BigDecimal</code>是否是整数倍数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal n = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;12.75&quot;</span>);</span><br><span class="line">BigDecimal m = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.15&quot;</span>);</span><br><span class="line">BigDecimal[] dr = n.divideAndRemainder(m);</span><br><span class="line"><span class="keyword">if</span> (dr[<span class="number">1</span>].signum() == <span class="number">0</span>) &#123;<span class="comment">//-1, 0, or 1 as the value of this, is negative, zero, or positive</span></span><br><span class="line">    <span class="comment">// n是m的整数倍</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>比较BigDecimal</strong></p>
<p>在比较两个<code>BigDecimal</code>的值是否相等时，要特别注意，使用<code>equals()</code>方法不但要求两个<code>BigDecimal</code>的值相等，还要求它们的<code>scale()</code>相等：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal d1 &#x3D; new BigDecimal(&quot;123.456&quot;);</span><br><span class="line">BigDecimal d2 &#x3D; new BigDecimal(&quot;123.45600&quot;);</span><br><span class="line">System.out.println(d1.equals(d2)); &#x2F;&#x2F; false,因为scale不同</span><br><span class="line">System.out.println(d1.equals(d2.stripTrailingZeros())); &#x2F;&#x2F; true,因为d2去除尾部0后scale变为2</span><br><span class="line">System.out.println(d1.compareTo(d2)); &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure></div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2021/04/13/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%AD%A6%E4%B9%A0_/"></a><a class="next" href="/2021/04/07/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_/"></a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://example.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/07/16/%E5%90%8C%E6%97%B6%E4%BE%9D%E8%B5%96%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93%E9%97%AE%E9%A2%98/">同时依赖不同版本的静态库问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/07/15/Android-FileProvider%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">Android FileProvider的使用及原理分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/07/15/Obj-C%E4%B8%ADProperty%E5%92%8CMethod%E5%8F%8AiVar%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%88%86%E6%9E%90-1/">Obj-C中Property和Method及iVar的可见性分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/27/%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E5%AD%A6%E4%B9%A0_/">消息转发学习_</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/26/Java%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0_/">Java反射学习_</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/13/Swift%20Method%20Dispatch%E6%9C%BA%E5%88%B6_/">Swift Method Dispatch机制_</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/13/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%AD%A6%E4%B9%A0_/">Java异常处理学习_</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/09/Java%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%AD%A6%E4%B9%A0_/">Java核心类学习_</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/07/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_/">Java面向对象编程学习笔记_</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/06/%E4%B8%BB%E5%B7%A5%E7%A8%8B%E5%92%8C%E4%B8%89%E6%96%B9SDK%E9%83%BD%E4%BE%9D%E8%B5%96%E7%9B%B8%E5%90%8C%E9%9D%99%E6%80%81%E5%BA%93%E9%97%AE%E9%A2%98/">主工程和三方SDK都依赖相同静态库问题</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">Blackchena.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>